#LinuxSHell 뽀개기

##SHELL VS KERNEL

### 정의
- 커널(Kernel) : 리눅스 운영체제의 핵심으로서 프로세스 관리, 메모리 관리, I/O 시스템 관리, 파일 시스템 관리 등을 수행
-> 1만줄 이상의 C 언어와 1000여줄의 어셈블리어로 구성되어 있어서 이식성이 좋다고 함.
- 쉘(Shell) : 사용자와 내부 커널 사이의 인터페이스 역할(명령어 해석기)

![UserUnix](https://lh6.googleusercontent.com/u4qXl8zPpgbPMsWrlQDFI_c_mTvx-Ynln-MG4-28Tbl5b6pqunlhjjlK7kV-3lPIuf_6sQOacNkmT1JQGDcI1oBIpFCnNeC6cvufbA6iewwXAmnPzVuja0RGoPLOi11O9puCRrI)
- 커널과 유저 사이에 셸이 있다. 사용자가 명령어를 입력하면 셸에게 전달되서 이를 해석하고 분석해서 `built in command`(ex)echo, cd, rm)를 통해서 하드웨어가 처리되고, 유저에게 결과를 전달하게 된다.

- 그림 2에서 도시된 대로 사용자(user)는 (보통은 키보드로) 명령을 입력하면 쉘에서 그 명령을 해독하여 커널에 전달한 후 그 결과를 출력하게 된다. 쉘을 사용하면 커널단의 복잡한 동작 방식을 알 필요 없이 쉘 상의 인터페이스로 시스템 자원들을 쉽게 관리할 수 있다. 이것이 바로 쉘이 탄생한 이유이기도 하다.

- 리눅스에서 쉘은 여러 종류가 있고 쉘마다 특징이 있다. 쉘은 본쉘(bourne shell, bash), C쉘(c shell, csh), 콘쉘(korn shell, ksh)이 있으며, 대부분의 리눅스 시스템에서 본쉘을 사용하고 있다. 본쉘은 쉘프로그래밍(도스로 치면 bat 파일로서 쉘명령어들의 모음)이 쉬운 반면 다른 쉘보다는 사용자와 상호 작용이 부족하다는 단점이 있다.



![shell, Kernel](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F27552535590AB2BB0F)
- 위와 같이 하드웨어를 Kernel이 감싸고 있고 이를 Shell이 감싸고 있다.

- 사용자가 입력한 명령어는 일련의 과정을 거쳐 하드웨어를 제어하게 됩니다. 사용자가 명령어를 작성하고 조작하기까지 이 사이에는 몇 가지의 과정을 거쳐서 수행을 하게 됨.
-  우리가 명령어를 입력하게 되면 컴퓨터 내부에서는 쉘(Shell) 이 이를 받아들이고, 
- 명령어를 해석하여 커널(Kernel) 을 통해 하드웨어를 조작합니다. 
- 즉, 제일 하단에는 하드웨어가 있고, 그 위에는 커널, 커널위에는 쉘, 그리고 쉘 위에는 사용자가 존재하여 사용자 유저의 입력을 받게 됩니다. 

### 커널
- 커널은 운영체제의 핵심입니다. 쉽게 말해, 소프트웨어와 하드웨어간의 커뮤니케이션을 관리하는 프로그램입니다.
- 운영체제에서 가장 중요한 구성요소로서 입출력을 관리하고 소프트웨어로부터의 요청을 컴퓨터에 있는 하드웨어(CPU, 메모리, 저장장치등)가 처리 할 수 있도록 요청을 변환하는 역할을 한다. 
- 이렇게 하드웨어를 관리하고 필요한 프로세스를 나눠주는 등 여러 시스템 자원을 제어하고, 컴퓨터 부팅시 부트로더에 의해 로드되어 항상 메모리에 상주하게 됩니다.

### 쉘
- 사용자와 운영체제간에 대화를 가능하게 해주는 명령어 해석기 역할을 말합니다.
- **사용자(명령) -> 쉘(해석) -> 커널(명령 수행 후 결과 전송) -> 쉘(해석) -> 사용자(결과 확인)**
## 하나의 kernel 다른 shell
![이미지](https://images.velog.io/images/jewon119/post/a88eb4c1-d05e-4848-923a-d775a05740af/linux-0203-1919.png)

- 유저마다 다른 Shell을 통해 접근하게 된다!

![kernel](https://docs.oracle.com/cd/E19683-01/806-5222/images/kernelovr.arch.epsi.gif)

## bash vs zsh
## echo
- `echo $0`을 터미널에 작성하게 되면 현재 어떤 Shell을 쓰는지 확인할 수 있다.

## bash Vs zsh

|목록|bash|zsh|
|:--:|:--:|:--:|
|공통점|||
|차이점1|cd tab하면 숨긴 파일까지 보임|cd tab하면 숨김 파일 보이지 않음|
|차이점2|cd /home/ubuntu|cd /h/u/ 하고 tab하면 자동완성!|
|차이점3|작동 불가|옆의 디렉토리 이동할 때 cd '원래 디렉토리' '바꾸고 싶은 디렉토리'로 가능|

## 디렉토리의 구조

- UNIX 계열에서는 실행 프로그램의 성격에 따라서 위치하는 규칙이 존재함
- "/" ⇢ 는 최상위 디렉토리로 root라 부름(cd /)
- "/bin" ⇢ 는 User Binaries로 사용자가 사용하는 명령들이 여기 있음
- "/sbin" ⇢ 는 System Binaries PC를 끄거나, 재부팅하는 등 스시템을 제어하는 명령들이 여기 존재함
- "/etc" ⇢ 모든 프로그램에 필요한 구성 파일이 들어있고, 여기서 파일을 수정하면 프로그램의 설정을 변경 할 수 있음
- "/dev" ⇢ 장치파일이 존재하는 디렉토리로 터미널 장치, USB 또는 시스템에 연결된 모든 장치를 포함함
- "/var" ⇢ 변수 파일을 나타내는 디렉토리로 파일을 사용할 때마다 변경됨
- "/tmp" ⇢ 임시 파일이 포함된 디렉토리로 재부팅할 때마다 삭제됨
- "/usr" ⇢ 바이너리, 라이브러리, 문서 및 소스 코드를 포함함.
- "/home" ⇢ 모든 사용자가 개인 파일을 저장할 수있는 홈 디렉토리로, "cd ~"로 어디서든 한번에 이동 가능함
- "/opt" ⇢ 소프트웨어를 설치할 때, 위치를 설정하지 않아도 적절한 디렉토리에 자동으로 설치해주는데 이를 opt에서 관여함. 프로그램을 설치할 때 경로를 직접 저장해줘야하는 경우 opt에 설치해주는 것이 좋은 방법이라 함.
- 프로그램이 어디에 설치되어있는지 찾는 방법 : whereis [프로그램명]

![계층 구조](https://media.vlpt.us/images/jewon119/post/64103170-2c21-4ede-86e8-4b48073f29e2/filesystem-structure.png)



### 출처
[생활코딩 Linux 1강](https://youtu.be/HYQ65yUlJDg)

[생활코딩 Linux 2강](https://youtu.be/VNF3BAEIUYs)

[jinShine 블로그](https://jinshine.github.io/2018/05/10/%EC%BB%B4%ED%93%A8%ED%84%B0%20%EA%B8%B0%EC%B4%88/%EC%BB%A4%EB%84%90(Kernel)%EA%B3%BC%20%EC%89%98(Shell)/)